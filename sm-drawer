#!/usr/bin/env tclsh

package require TclOO
package require Tk

# TODO
#
# - draw transitions
# - save/load
# - ensure each state name is unique
# - metadata (class names + identifiers + foobar)
# - hierarchical states
# - make everything prettier

# wrap canvas object
oo::class create my_app {
    variable Canvas StateIdx Selected Transitions States CurState
    constructor {c} {
        set Canvas $c
        set StateIdx 0
        set Selected {}
        set CurState idle
        set Transitions {}
        set States {}

        canvas $c -background white
        button .q -text {Quit} -command exit
        label .l -text {Idle}
        button .a -text {Add State} -command "[self object] switch_to_add_state_mode"
        button .t -text {Add Transition} -command "[self object] switch_to_add_transition_mode"

        pack .a .t -side top
        pack $Canvas -expand true -fill both
        pack .q .l -side bottom
    }
    destructor {
        destroy $Canvas
    }
    method set_status_bar {text} {
        .l configure -text $text
    }
    method switch_to_add_state_mode {} {
        if {$CurState != "idle"} {
            return
        }
        set CurState addState
        bind $Canvas <Button-1> "[self object] add_state %x %y"
        $Canvas configure -cursor crosshair
        my set_status_bar {Click to add new state...}
    }
    method add_state {x y} {
        if {$CurState != "addState"} {
            return
        }
        set CurState idle
        bind $Canvas <Button-1> {}
        $Canvas configure -cursor left_ptr
        my set_status_bar {Idle}
        incr StateIdx
        lappend States [state new $Canvas [self object] $x $y "state$StateIdx"]
    }
    method switch_to_add_transition_mode {} {
        if {$CurState != "idle"} {
            return
        }
        my set_status_bar {Select the first state...}
        set CurState addTransition
    }
    method select {obj} {
        if {$CurState != "addTransition"} {
            return false
        }
        if {$Selected == {}} {
            set Selected $obj
            my set_status_bar {Select the second state...}
            return true
        } else {
            lappend Transitions [transition new $Canvas $Selected $obj]
            # deselect other state
            $Selected deselect
            set Selected {}
            set CurState idle
            my set_status_bar {Idle}
            return false
        }
    }
    method deselect {obj} {
        if {$Selected != {}} {
            my set_status_bar {Idle}
            set Selected {}
        }
    }
    method popup_menu {obj} {
        if {[winfo exists .popup]} {
            destroy .popup
        }
        tk::toplevel .popup
        wm transient .popup .
        wm overrideredirect .popup true
        wm attributes .popup -type popup_menu
        label .popup.l -text "Menu: [$obj get_name]"
        entry .popup.e
        .popup.e insert 0 [$obj get_name]
        button .popup.r -text "Rename" -command "$obj rename {.popup.e get}; destroy .popup"
        button .popup.d -text "Delete" -command "$obj destroy; destroy .popup"
        button .popup.c -text "Close" -command "destroy .popup"
        pack .popup.l .popup.e .popup.r .popup.d .popup.c
    }
}

oo::class create state {
    variable Canvas App Id Name Selected Listeners
    constructor {c a x y name} {
        set Canvas $c
        set App $a
        set Name $name
        set Selected false
        set Listeners {}
        set Id [$Canvas create text $x $y -text $name -fill black -activefill red]
        $Canvas bind $Id <Button-1> "[self object] select"
        $Canvas bind $Id <B1-Motion> "[self object] move %x %y"
        $Canvas bind $Id <3> "$App popup_menu [self object]"
    }
    destructor {
        my emit destroyed
        $Canvas delete $Id
    }
    method get_name {} {
        return $Name
    }
    method register {dst} {
        lappend Listeners $dst
    }
    method emit {args} {
        foreach listener $Listeners {
            $listener notify [self object] {*}$args
        }
    }
    method move {x y} {
        $Canvas moveto $Id $x $y
        my emit move $x $y
    }
    method get_coords {} {
        $Canvas coords $Id
    }
    # new_name is a function, not a string
    # TODO ask Alex about this
    method rename {new_name} {
        set Name [{*}$new_name]
        $Canvas dchars $Id 0 end
        $Canvas insert $Id end $Name
    }
    method select {} {
        if {[$App select [self object]]} {
            # select is ok now
            set Selected true
            $Canvas itemconfigure $Id -fill blue -activefill red
        }
    }
    method deselect {} {
        set Selected false
        $Canvas itemconfigure $Id -fill black -activefill red
        $App deselect [self object]
    }
}

oo::class create transition {
    variable Canvas Src Dst Id
    constructor {canvas src dst} {
        set Canvas $canvas
        set Src $src
        set Dst $dst
        set Id {}
        my CreateLine
        $Src register "[self object]"
        $Dst register "[self object]"
    }
    destructor {
        $Canvas delete $Id
    }
    method CreateLine {} {
        if {$Id != {}} {
            $Canvas delete $Id
        }
        set Id [$Canvas create line {*}[$Src get_coords] {*}[$Dst get_coords] -arrow last]
    }
    method notify {src command args} {
        switch -exact $command {
            move {
                # TODO howto move line instead of replacing it?
                my CreateLine
            }
            destroyed {
                my destroy
            }
        }
    }
}

#### Setup canvas + widgets

my_app new .c
