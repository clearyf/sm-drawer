#!/usr/bin/env tclsh

package require TclOO
package require Tk

# Note that all unit tests are run when the program starts.

# TODO
#
# high priority
#
# ?
#
# next major feature
#
# - hierarchical states
#
# nice to have
#
# - support multiple points on transitions
# - class name (probably not required)
# - mark parallel states



# some tracing/logging infrastructure
proc enter {mesg} {
    # puts "ENTER: $mesg"
}

proc leave {mesg} {
    # puts "LEAVE: $mesg"
}



# notifier class ala QObject signals/slots
oo::class create notifier {
    variable Listeners DestroyPending
    constructor {} {
        enter "[self object] new"
        set Listeners [dict create]
        set DestroyPending {}
        leave "[self object] new"
    }
    destructor {
        enter "[self object] destroy"
        if {$DestroyPending != {}} {
            # this could be the sign of a mistake, as if an object is
            # pending deletion then direct destroy is probably a
            # mistake.
            # TODO check "after info $DestroyPending"?
            after cancel $DestroyPending
        }
        my emit destroyed
        leave "[self object] destroy"
    }
    # gotcha here with notifications is if the "destroyed" signal is
    # used to destroy another object eg:
    #
    # $obj1 connect destroyed $obj2 destroy
    #
    # then the list of objects is invalidated during iteration!
    # Solution is if an object should be destroyed when another one is
    # destroyed then the method called to destroy the object is this
    # one here "destroy_later" which will schedule destruction later
    # when the event loop is idle.
    #
    # An alternative would be to match in the connect method on
    # destroyed -> destroy, but that would not catch methods that
    # indirectly call destroy.  Best thing is to trigger an error in
    # these cases so it gets caught straightaway.
    method destroy_later {} {
        # Make sure to only call destroy once on this object.
        if {$DestroyPending == {}} {
            set DestroyPending [after idle [self object] destroy]
        }
    }
    method get_connections {} {
        return $Listeners
    }
    method connect {name dst args} {
        enter "[self object] connect $name $dst $args"
        if {$name == {destroyed} && $args == {destroy}} {
            error "Cannot connect destroyed to destroy, use destroy_later!"
        }
        if {[dict exists $Listeners $name]} {
            set idx [lsearch -exact [dict get $Listeners $name] [list $dst {*}$args]]
            if {$idx != -1} {
                # already present, break loop.  when a connection is
                # made a second connection is made to make sure that
                # we disconnect the signal if the destination object
                # is destroyed.
                leave "[self object] connect $name $dst $args -> false"
                return false
            }
        }
        dict lappend Listeners $name [list $dst {*}$args]
        # monitor destroyed signal from dst, so we can disconnect it
        # when it is destroyed and don't call methods on non-existent
        # objects.
        $dst connect destroyed [self object] disconnect_obj $dst
        leave "[self object] connect $name $dst $args -> true"
        return true
    }
    method disconnect {name dst args} {
        enter "[self object] disconnect $name $dst $args"
        if {[dict exists $Listeners $name]} {
            set entries [dict get $Listeners $name]
            set idx [lsearch -exact $entries [list $dst {*}$args]]
            if {$idx != -1} {
                dict set Listeners $name [lreplace $entries $idx $idx]
                leave "[self object] disconnect $name $dst $args -> true"
                return true
            }
        }
        leave "[self object] disconnect $name $dst $args -> false"
        return false
    }
    # this loops through all connections and disconnects just one
    # object
    method disconnect_obj {dst} {
        enter "[self object] disconnect_obj $dst -> $Listeners"
        dict for {k v} $Listeners {
            set entries [dict get $Listeners $k]
            set indices {}
            for {set i 0} {$i<[llength $entries]} {incr i} {
                if {[lindex [lindex $entries $i] 0] == $dst} {
                    lappend indices $i
                }
            }
            # remove element in reverse order as otherwise the later
            # indices become invalid
            foreach index [lreverse $indices] {
                set entries [lreplace $entries $index $index]
            }
            dict set Listeners $k $entries
        }
        leave "[self object] disconnect_obj $dst -> $Listeners"
    }
    method emit {name args} {
        enter "[self object] emit $name $args"
        if {[dict exists $Listeners $name]} {
            foreach listener [dict get $Listeners $name] {
                {*}$listener {*}$args
            }
        }
        leave "[self object] emit $name $args"
    }
}



# test class to test various bits of notifier functionality
oo::class create test_notifier {
    superclass notifier
    variable Heard
    constructor {} {
        set Heard false
        next
    }
    destructor {
        next
    }
    method beep {} {
        my emit beep
    }
    method listen_to {obj} {
    }
    method somebody_beeped {} {
        set Heard true
    }
    method heard_beep {} {
        return $Heard
    }
}

# test is fairly straightforward, first create the two instances
set foo [test_notifier new]
set bar [test_notifier new]
$bar beep
# nothing should have been heard yet from bar by foo
if {[$foo heard_beep]} {
    error "Beep already heard"
}
# foo should monitor the beep from foo
$bar connect beep $foo somebody_beeped
# this time it should be heard
$bar beep
if {![$foo heard_beep]} {
    error "Beep wasn't heard"
}
# test that this gives us an error
if {![catch {$foo connect destroyed $bar destroy}]} {
    error "connect destroyed -> destroy should be an error!"
}
# test add destroy_later for tearing down networks of notifiers
$foo connect destroyed $bar destroy_later
$foo destroy
# bar should only get destroyed when the event loop is entered
if {![info object isa object $bar]} {
    error "Test object was unexpectedly destroyed!"
}
# enter event loop to process waiting destroy_later event
update
# bar should now be destroyed
if {[info object isa object $bar]} {
    error "Test object is unexpectedly still alive!"
}
# end of test cases



oo::class create my_app {
    superclass notifier
    variable Canvas StateIdx Selected Transitions States CurState
    constructor {c} {
        next
        set Canvas $c
        set StateIdx 0
        set Selected {}
        set CurState idle
        set Transitions {}
        set States {}

        canvas $c -background white
        button .save -text {Save} -command [list [self object] save]
        button .load -text {Load} -command [list [self object] load]
        button .quit -text {Quit} -command exit
        label .status_bar -text {Idle}
        button .add_state -text {Add State} -command [list [self object] switch_to_add_state_mode]
        button .add_trans -text {Add Transition} -command [list [self object] switch_to_add_transition_mode]

        pack .add_state .add_trans -side top
        pack $Canvas -expand true -fill both
        pack .quit .status_bar .load .save -side bottom

        bind . <Escape> "[self object] cancel_current_op"
    }
    destructor {
        # teardown all notifications  before destroying the canvas
        next
        destroy $Canvas
    }
    method set_status_bar {text} {
        .status_bar configure -text $text
    }
    method cancel_current_op {} {
        $Canvas configure -cursor left_ptr
        my set_status_bar {Idle}
        set CurState idle
        if {$Selected != {}} {
            $Selected deselect
            set Selected {}
        }
    }
    method save {} {
        set f [open {saved_data.ini} {w}]
        foreach state $States {
            $state serialise $f
        }
        foreach transition $Transitions {
            $transition serialise $f
        }
        close $f
    }
    method CreateObject {mode d} {
        switch -exact -- $mode {
            State {
                if {[dict exists $d name]
                    && [dict exists $d type]
                    && [dict exists $d position]} {
                    set new_state [state new $Canvas [self object] {*}[dict get $d position] [dict get $d name]]
                    lappend States $new_state
                    $new_state connect destroyed [self object] state_destroyed $new_state
                    $new_state set_type [dict get $d type]
                } else {
                    puts "Don't have enough information to construct a state: $d"
                }
            }
            Transition {
                if {[dict exists $d from]
                    && [dict exists $d to]
                    && [dict exists $d points]
                    && [dict exists $d event]} {

                    set src [my get_state [dict get $d from]]
                    set dst [my get_state [dict get $d to]]

                    set new_transition [transition new $Canvas [self object] $src $dst [dict get $d event]]
                    lappend Transitions $new_transition
                    $new_transition set_points [dict get $d points]
                    $new_transition connect destroyed [self object] transition_destroyed $new_transition
                } else {
                    puts "Don't have enough information to construct a transition: $d"
                }
            }
            default {
                puts "Don't know what to do with a $mode with $d"
            }
        }
    }
    method load {} {
        if {$CurState != {idle}} {
            return
        }
        while {[llength $States] > 0} {
            [lindex $States end] destroy
        }
        # destroying all states destroys all transitions too

        set f [open {saved_data.ini} {r}]
        set d [dict create]
        set mode {}
        while {[gets $f line] >= 0} {
            switch -regexp -matchvar value -- $line {
                {\[(.*)\]} {
                    if {$mode != {}} {
                        my CreateObject $mode $d
                    }
                    set mode [lindex $value 1]
                    set d [dict create]
                }
                {([^=]+)=(.+)}  {
                    dict set d [lindex $value 1] [lindex $value 2]
                }
                default {
                    puts "Error parsing state: $line"
                }
            }
        }
        # eof, create very last object
        my CreateObject $mode $d
        close $f
    }
    method get_state {name} {
        foreach state $States {
            if {$name == [$state get_name]} {
                return $state
            }
        }
        throw STATE_NOT_FOUND "No state called $name found!"
    }
    method switch_to_add_state_mode {} {
        if {$CurState != {idle}} {
            return
        }
        set CurState addState
        bind $Canvas <Button-1> "[self object] add_state %x %y"
        $Canvas configure -cursor crosshair
        my set_status_bar {Click to add new state...}
    }
    method add_state {x y} {
        if {$CurState != {addState}} {
            return
        }
        set CurState idle
        bind $Canvas <Button-1> {}
        $Canvas configure -cursor left_ptr
        my set_status_bar {Idle}
        # loop until there is no state with this name; this is
        # required in case we save a state graph and then load it
        # again.  Alternative would be save the StateIdx in the saved
        # data, but we don't want to leak implementation details like
        # that.
        try {
            while {true} {
                incr StateIdx
                my get_state "state$StateIdx"
            }
        } trap {STATE_NOT_FOUND} {} {}
        set new_state [state new $Canvas [self object] $x $y "state$StateIdx"]
        lappend States $new_state
        $new_state connect destroyed [self object] state_destroyed $new_state
    }
    method state_destroyed {state} {
        set idx [lsearch -exact $States $state]
        set States [lreplace $States $idx $idx]
    }
    method switch_to_add_transition_mode {} {
        if {$CurState != {idle}} {
            return
        }
        my set_status_bar {Select the first state...}
        $Canvas configure -cursor crosshair
        set CurState addTransition
    }
    method select {obj} {
        if {$CurState != {addTransition}} {
            return false
        }
        if {$Selected == {}} {
            set Selected $obj
            my set_status_bar {Select the second state...}
            return true
        } else {
            set new_transition [transition new $Canvas [self object] $Selected $obj "foobar"]
            lappend Transitions $new_transition
            $new_transition connect destroyed [self object] transition_destroyed $new_transition
            $Selected deselect
            $Canvas configure -cursor left_ptr
            set Selected {}
            set CurState idle
            my set_status_bar {Idle}
            return false
        }
    }
    method deselect {obj} {
        if {$Selected != {}} {
            my set_status_bar {Idle}
            set Selected {}
        }
    }
    method transition_destroyed {transition} {
        set idx [lsearch -exact $Transitions $transition]
        set Transitions [lreplace $Transitions $idx $idx]
    }
    method popup_destroy {obj} {
        set answer [tk_messageBox -message "Delete [$obj get_name]?" \
                        -icon question -type yesno]
        switch -- $answer {
            yes {$obj destroy}
        }
    }
    method popup_rename_state {obj} {
        set new_name [.popup.e get]
        foreach state $States {
            if {$obj != $state && $new_name == [$state get_name]} {
                tk_messageBox -message "There is already a state called [$obj get_name]!" \
                        -icon error -type ok
                return
            }
        }
        .popup.l configure -text "Menu: $new_name"
        $obj rename $new_name
    }
    method popup_state_menu {obj x y} {
        if {[winfo exists .popup]} {
            destroy .popup
        }
        tk::toplevel .popup
        wm transient .popup .
        wm overrideredirect .popup true
        wm attributes .popup -type popup_menu
        set parent_geo [winfo geometry .]
        regexp {[0-9]+x[0-9]+\+([0-9]+)\+([0-9]+)} $parent_geo parent_geo parent_x parent_y
        # make popup appear somewhere near the mouse cursor...
        wm geometry .popup "+[expr {$x + $parent_x}]+[expr {$y + $parent_y}]"
        label .popup.l -text "Menu: [$obj get_name]"
        label .popup.t -text "Type: [$obj get_type]"
        entry .popup.e
        .popup.e insert 0 [$obj get_name]
        button .popup.r -text {Rename} -command [list [self object] popup_rename_state $obj]
        button .popup.i -text {Set Initial} -command [list [self object] set_state_type $obj initial]
        button .popup.n -text {Set Normal} -command [list [self object] set_state_type $obj normal]
        button .popup.f -text {Set Final} -command [list [self object] set_state_type $obj final]
        button .popup.d -text {Delete} -command [list [self object] popup_destroy $obj]
        button .popup.c -text {Close} -command [list destroy .popup]
        pack .popup.l .popup.t .popup.e .popup.r .popup.i .popup.f .popup.n .popup.d .popup.c -fill x
    }
    method popup_transition_menu {obj x y} {
        if {[winfo exists .popup]} {
            destroy .popup
        }
        tk::toplevel .popup
        wm transient .popup .
        wm overrideredirect .popup true
        wm attributes .popup -type popup_menu
        set parent_geo [winfo geometry .]
        regexp {[0-9]+x[0-9]+\+([0-9]+)\+([0-9]+)} $parent_geo parent_geo parent_x parent_y
        # make popup appear somewhere near the mouse cursor...
        wm geometry .popup "+[expr {$x + $parent_x}]+[expr {$y + $parent_y}]"
        label .popup.l -text "Menu: [$obj get_name]"
        entry .popup.e
        .popup.e insert 0 [$obj get_name]
        button .popup.r -text {Rename} -command [list [self object] rename_transition $obj]
        button .popup.d -text {Delete} -command [list [self object] popup_destroy $obj]
        button .popup.c -text {Close} -command [list destroy .popup]
        pack .popup.l .popup.e .popup.r .popup.d .popup.c -fill x
    }
    method rename_transition {obj} {
        .popup.l configure -text "Menu: [.popup.e get]"
        $obj rename [.popup.e get]
    }
    method set_state_type {obj type} {
        # can only have one initial or final state in each state
        # machine.  if the target type is normal then this is
        # effectively nop
        foreach state $States {
            if {[$state get_type] == $type} {
                $state set_normal
                break
            }
        }
        $obj set_type $type
        .popup.t configure -text "Type: [$obj get_type]"
    }
}



oo::class create state {
    superclass notifier
    variable Canvas App Name Selected Tid Rid PointerOffset Type
    constructor {c a x y name} {
        next
        set Canvas $c
        set App $a
        set Name $name
        set Selected false
        set PointerOffset [list 0 0]
        set Tid [$Canvas create text $x $y -text $name -fill black -activefill red]
        set Rid [$Canvas create rectangle [$Canvas bbox $Tid]]
        my set_normal
        $Canvas lower $Rid $Tid
        $Canvas bind $Tid <ButtonPress-1> "[self object] save_pointer_offset %x %y"
        $Canvas bind $Rid <ButtonPress-1> "[self object] save_pointer_offset %x %y"
        $Canvas bind $Tid <B1-Motion> "[self object] move %x %y"
        $Canvas bind $Rid <B1-Motion> "[self object] move %x %y"
        $Canvas bind $Tid <3> "$App popup_state_menu [self object] %x %y"
        $Canvas bind $Rid <3> "$App popup_state_menu [self object] %x %y"
    }
    destructor {
        $Canvas delete $Tid
        $Canvas delete $Rid
        next
    }
    # On ButtonPress save the location of the pointer so we have a
    # basis for moving the state without it jumping all over the
    # place.
    method save_pointer_offset {x y} {
        lassign [my get_entry_coords] nw_x nw_y
        set PointerOffset [list [expr {$x - $nw_x}] [expr {$y - $nw_y}]]
        # call next action
        my select
    }
    method get_entry_coords {} {
        return [lrange [$Canvas bbox $Tid] 0 1]
    }
    method get_exit_coords {} {
        return [lrange [$Canvas bbox $Tid] 2 3]
    }
    method serialise {f} {
        puts $f "\[State\]"
        puts $f "name=[my get_name]"
        puts $f "type=[my get_type]"
        puts $f "position=[my get_coords]"
    }
    method get_name {} {
        return $Name
    }
    method move {new_x new_y} {
        lassign $PointerOffset offset_x offset_y
        set x [expr {$new_x - $offset_x}]
        set y [expr {$new_y - $offset_y}]
        $Canvas moveto $Tid $x $y
        $Canvas moveto $Rid $x $y
        my emit redrawn
    }
    method get_coords {} {
        $Canvas coords $Tid
    }
    method rename {new_name} {
        set Name $new_name
        $Canvas dchars $Tid 0 end
        $Canvas insert $Tid end $Name
        $Canvas delete $Rid
        # repaint canvas
        set Rid [$Canvas create rectangle [$Canvas bbox $Tid] -fill lightgrey]
        $Canvas lower $Rid $Tid
        my emit redrawn
    }
    method get_type {} {
        return $Type
    }
    method set_type {type} {
        switch -exact $type {
            normal { my set_normal }
            initial { my set_initial }
            final { my set_final }
        }
    }
    method set_normal {} {
        set Type normal
        $Canvas itemconfigure $Rid -fill lightgrey
    }
    method set_initial {} {
        set Type initial
        $Canvas itemconfigure $Rid -fill skyblue
    }
    method set_final {} {
        set Type final
        $Canvas itemconfigure $Rid -fill lightgreen
    }
    method select {} {
        if {[$App select [self object]]} {
            # select is ok now
            set Selected true
            $Canvas itemconfigure $Tid -fill blue -activefill red
        }
    }
    method deselect {} {
        set Selected false
        $Canvas itemconfigure $Tid -fill black -activefill red
        $App deselect [self object]
    }
}



oo::class create transition {
    superclass notifier
    variable Canvas App Src Dst Event MidPoint Lid Cid Tid
    constructor {canvas a src dst event} {
        next
        set Canvas $canvas
        set App $a
        set Src $src
        set Dst $dst
        set Event $event
        set Lid {}
        set Cid {}
        set Tid {}
        set MidPoint [my GetMidPointCoords]
        my CreateLine
        $Src connect destroyed [self object] destroy_later
        $Dst connect destroyed [self object] destroy_later
        $Src connect redrawn [self object] redraw
        $Dst connect redrawn [self object] redraw
    }
    destructor {
        next
        $Canvas delete $Lid
        $Canvas delete $Cid
        $Canvas delete $Tid
    }
    method serialise {f} {
        puts $f "\[Transition\]"
        puts $f "from=[$Src get_name]"
        puts $f "to=[$Dst get_name]"
        puts $f "points=$MidPoint"
        puts $f "event=$Event"
    }
    method CreateLine {} {
        if {$Lid != {}} {
            $Canvas delete $Lid
        }
        # TODO "-smooth true", try with two midpoints for curvy fun
        set Lid [$Canvas create line {*}[my GetLineAllCoords] -arrow last]
        $Canvas lower $Lid
        if {$Cid == {}} {
            set Cid [$Canvas create oval [my GetCircleCoords] -fill black -activefill red]
            set Tid [$Canvas create text [my GetTextCoords] -text $Event]
            $Canvas raise $Cid $Lid
            $Canvas raise $Cid $Tid
            $Canvas bind $Cid <B1-Motion> "[self object] move_circle %x %y"
            $Canvas bind $Cid <3> "$App popup_transition_menu [self object] %x %y"
        }
    }
    method rename {name} {
        set Event $name
        $Canvas dchars $Tid 0 end
        $Canvas insert $Tid end $Event
    }
    method set_points {points} {
        set MidPoint $points
        my CreateLine
        $Canvas moveto $Cid {*}[lrange [my GetCircleCoords] 0 1]
        $Canvas moveto $Tid {*}[my GetTextCoords]
    }
    method move_circle {x y} {
        # TODO fix moving to be smooth like the state
        my set_points [list $x $y]
    }
    method get_name {} {
        return $Event
    }
    method GetTextCoords {} {
        lassign $MidPoint x y
        return [list [expr {$x + 3}] [expr {$y + 3}]]
    }
    method GetLineCoords {} {
        return [list {*}[$Src get_exit_coords] {*}[$Dst get_entry_coords]]
    }
    method GetLineAllCoords {} {
        return [list {*}[$Src get_exit_coords] {*}$MidPoint {*}[$Dst get_entry_coords]]
    }
    method GetMidPointCoords {} {
        lassign [my GetLineCoords] lsx lsy lex ley
        return [list [expr {$lsx + ($lex - $lsx) / 2}] [expr {$lsy + ($ley - $lsy) / 2}]]
    }
    method GetCircleCoords {} {
        lassign $MidPoint mx my
        set r 3
        return [list [expr {$mx - $r}] [expr {$my - $r}] [expr {$mx + $r}] [expr {$my + $r}]]
    }
    method redraw {args} {
        # TODO howto move line instead of replacing it?
        my CreateLine
    }
}


#### Setup canvas + widgets

my_app new .c
